    Follow unfollow API

    На странице FindUsers подписаться или отписаться от user, есть кнопка follow onFollow, логика которой уже
реализовали локально. В UI сейчас мы нажимаем кнопки и у нас идет follow onFollow, меняется BLL и соответственно
происходит перерисовка, FLUX круговорот, мы диспатчим при нажатии на кнопу, а должны диспатчить при подтверждении
сервером, что мы подписались.
    Из UI отправляем запрос на сервер, сервер нам отвечает что все ок, и только после этого мы диспатчим в BLL - store.
Важный момент - мы будем подписываться и отписываться, соответственно мы когда делаем запрос на сервер, должны быть
залогиненны. Если мы не залогинены то мы не можем не подписаться не отписаться. Мы должны указать ID того на кого
хотим подписаться, но кто я такой указывать не должен, так как cookie автоматически цепляются к каждому запросу и уходят
и в этих куках зашифрованна инфа кто я такой. Соответственно сервер получает на кого подписаться и подписывается.

    Чтобы подписатся нужно отправить post запрос, чтобы отписаться мы должны отправить тип запроса delete.
    GET, POST, DELETE запросу похожи, у них везде есть URL куда мы делаем запросы.
    В чем разница? HTTP раньше поддерживал все запросы. Сейчас есть такое понятие как REST API - это как бы
    условная договоренность как можно организовать процесс работы с сервером чтобы это было однообразно из
    проекта в проект, чтобы поддерживались все фичи которые поддерживаются HTTP протоколом.
    GET запрос чтобы получить данные, есть один эндпойнт, чтобы работать с чем то одним, например с юзером,
    фотографией с подпиской, отпиской.
    POST чтобы создать, запостить на стену - создать что то новое.
    DELETE стобы удалить.
    Эндпойнт используется один и тот же он характиризуется URL адресом, просто отправляем разный тип запроса.
    С помощью AXIOS библиотеки это делать легко просто вызываем разный метод. GET, POST, PUT, DELETE.

    И так. Мы должны быть залогинены так как наша кука должна существовать в том браузере, с которым мы будем
работать с нашей соц сетью. Для того что бы получить информацию что мы авторизованны, нужно отправить withCredentials.


!!!Action creators которые сидят в mapDispatchToProps follow unFollow, не означает что сокращенный синтаксис отдает AC
отдали компоненте и компонента его вызывает. Компонента вызывает некоторую колбэк функцию, Connect автоматически создал
за нас эту колбэк функцию, в которой он вызывает followAC, AC возвращает action, action диспатчится.

    Когда мы хотим подписаться, мы делаем POST запрос на сервер, вписываем нужный адрес, смотрим в апишке follow/userId.
    Что бы отправлять авторизацию, в POST мы withCredentials: true передается третьим параметром, поэтому, вторым пере-
    даем null или {} пустой объект.

    Подписались на пользователя, в response.data.resultCode, resultCode мы будем всегда анализировать - так как когда
на сервер мы отправляем какие то запросы с действиями - POST, DELETE, PUT, как правило сервер возвращает ответы в
однообразном стиле, зависит это и от серверных разработчиков, какой они продумали интерфейс.
    if (resultCode === 0) {
        то выполняем действие
    }
 Если запрос не прошел, то одна из возможных причин, что все запросы кроме get требуют обязательного ключа доступа.
 Генерируем ключ в Social network API в настройках аккаунта. И добавляем его в запрос. Обязательно ключ доступа должен
 соответствовать нашейзалогиненой айдишке - нашему аккаунту. Иначе работать не будет.
    Куда его добавить, там где у нас объект с настройками где мы добавляем withCredentials, ставим headers, это заголовки
с каждым запросом на сервер и с каждым ответом по мимо того что мы видим, отправляется еще автоматически браузером

headers - заголовки и сервером возвращаются в респонсе тоже headers. Accept - какой тип данных мы хотим принять
Origin - с какого домена мы делаем запрос, Referer с какой страницы мы делаем запрос, User-Agent - наш текущий браузер.
    Политика cors кому разрешено делать запрос, в 3000 порту разрешено например.
cache-control: no-cache - значит чтокэшировать браузер не надо. Каждый раз нужно запрашивать и получать данные с сервера.
content-type: -какой контент вернулся.
И вот с этими реквест заголовками должны отправить еще ключ. Для этого цепляем к свойству headers: {api-key: ключ.}
    На данном этапе, если по нажатию на отписку или подписку ни чего не меняется, то есть, при на жатии follow так и остается
follow и статус не поменялся resultCode: 1, и сообщение показывает то мы уже подписаны на юзера. Вспоминаем что у нас
при переходе по страницам делается запрос за юзерами, у нас возвращаются юзеры и там сразу сидит значение - followed: false
оказывается мы на юзера подписаны, а сервер возвращает false - это произошло потому что запрос за пользователем
был сделан анонимно, то есть не установлен withCredentials: true, в запросах на сервер в компоненте userContainer,
поэтому сервер дает по умолчанию false. Поэтому устанавливаем withCredentials: true, в запросах за пользователями и
в запросах выбора страницы.
    Метод options - сервер понимает что мы находимся на http://localhost/ шлем запросы на social network samurai.js и
браузер понимает что, что-то не так, и он шлет, перед основным запросом DELETE например, так называемый предфлый запрос.
Чтобы сервер дал ему ответ на этот options и сказал да, запрос можно слать.
    Если такой ответ даст:
    Response Headers:
    access-control-allow-credentials: true
    access-control-allow-headers: api-key
    access-control-allow-methods: GET, POST, PUT, DELETE, OPTIONS.
    access-control-allow-origin: http://localhost:3000
    Браузер разрешает делать запросы и пропускает второй запрос.

    Почему мы считаем что если мы подписываемся то это POST мы создаем что-то, а DELETE удаляем. Это вопрос холиварный
    так как зависит от разработчика, как идеологически он это понимает.