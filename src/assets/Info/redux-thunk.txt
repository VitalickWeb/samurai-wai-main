   В классическом подходе UI  общается с BLL, BLL общается с DAL, UI в DAL не лезет.
 UI компонента должна заниматся юзеринтрефейсом а у нас просиходят запросы на сервер, а ее
 респонсибилити должно быть такое, то что пользователь видит и какие пользователь осуществляет действия.
 Поэтому запросы на сервер мы должны делегировать уровню DAL.

 При взаимодействии с UI идет круговорот сначала обращение к BLL, BLL идет в DAL и в DAL уже
 идет взаимодействие с сервером. После сервер возвращает данные, BLL данные эти в state преобразует, и
 в UI перерисуется узел.
    В BLL происходит асинхронный запрос на сервер, который мы обернули в нутрь какогото метода,
    внутрь какогото объекта.
 Мы можем через UI пинать BLL только с помощью dispatch экшенов, мы диспатчим action, action приходит
 в BLL и дальше какбы BLL должен сделать запрос на сервак через какой то промежуточный слой.
    BLL - Redux, в redux у нас есть store. У store есть три метода getState, subscribe, dispatch.
    И мы из реакта диспатчим action -> дальше конкретные части action раскидываются по редьюссерам.
    Редьюссеры условно говоря по очереди все вызываются и формируется новый стэйт.
!Важнфй момент - редьюсер обязан вернуть state  максимально быстро сразу и синхронно. Тоесть в редьюссер
пришло управление, редьюсер сразу меняет state и сразу возвращает новый вариант стэйта.
    Так как асинхронщина которая происходит в другом потоке - мире, соответственно мы не можем инициировать
    запрос в редьюссере, так как reducer это чисатая функция которая лишина побочных эффектов
Мы можем из функции брать куски кода и объединять в функции, но эта фукнция должна уйти в бизнесс логику
к примеру thunk === addMessage. И эта функция которая делает в нутри себя асинхронные запросы,
то есть логика диспатчинья чего то одного, потом асинхронный запрос, потом диспачтим что то другое, третье -
это и есть санка - thunk. Функция которая делает все перечисленное.
 Нам Нужно эту thunk диспатчить, так как реакт умеет взаимодействовать только со store через dispatch,
 а санка === функция, а диспатчить мы умеем только action === object у которого как минимум есть свойство type
 И получается что мы задиспатчили функцию, а функцию мы не можем отдать в reducer. reducer - это чистая функция
 которая принимает старый стэйт, action который нужно применить к этому стэйту и возвращает измененный новый
  стэйт. А тут приходит функция с асинхронными запросами, и редьюсер ее запустить не может.
  Поэтому эта функция должна запутится до отправки в reducer, и не должна попасть в них. Поэтому
  мы диспатчим thunk предназначенную кому то другому, функция должна просто запустится, в нутри будет
  происходить какая то логика и в нутри уже будут обычные диспатчи обычных action и эти action уже будут раскиданы
  по редьюсерам.
                Thunk - это функция которая делает какую то асинхронную задачу и которая умеет диспатчить обычные
                action. Идея санки что ее можно тоже задиспатчить и store поймет что с ней делать, store не пустит ее
                в reducer, но запустит потому что thunk это функция.
        Все бы хорошо но мы диспатчим добавление сообщения, в нее приходит функция метод диспатч

        const addPost = (dispatch) => {
        dispatch(onLoding()) - вызываем обычный AC включи загрузку
        axios.post({message}).then(() => { - потом делаем асинхронный запрос с сообщением, после когда ответ приходит             dispatch(addPost(message))
            dispatch(addPost(message))
            dispatch(offLoading()) - мы диспатчим добавление поста и выключаем загрузку
            })
        }
        Важный момент - чтобы эта функция могла диспатчить обычные action - у нее должна быть функция dispatch
        поэтому она придет в параметрах.
        Кто функцию thunk запускает - мы диспатчим функцию а редакс стор ее уже запустит. Соответственно редакс стор
        закинет в параметр функцию dispatch.
        Важный момент, нам нужно текст передать, в параметре мы не можем ее передать так как мы не вызываем эту
        функцию и не можем передать massage в эту thunk, потому что не мы вызываем эту санку, санку вызывает store.
        Напомощь нам придет замыкание, замыкание появляется там где функция возвращает другую функцию и эта другая функция
        возвращенная имеет доступ к родительским данным родительской функции из которой ее вернули.
        Для этого мы создадим thankcreator как и actioncreator, нам нужна какая то функция которая будет создавать
        нашу thunk:

        const addPostThunkCreator = (message) => (dispatch) {
            dispatch(onLoding()) - вызываем обычный AC включи загрузку
            axios.post({message}).then(() => { - потом делаем асинхронный запрос с сообщением, после когда ответ приходит
                dispatch(addPost(message))
                dispatch(offLoading()) - мы диспатчим добавление поста и выключаем загрузку
            })
        }

        Store не умеет принимать в качестве диспатча функцию, так как он не умеет ее запускать, он ждет только
        объекты, поэтому выпадет ошибка. Нам нужно вклинится в этот кусок кода как промежуточное связующее звено
        midleware и если придет action то отдать его в редьюсеры а если функция то мы ее запутим.

            Если мы будем диспатчить action то он придет в store.dispatch, попадет в thunk MW который поймет что это не
        thunk и вернет action в reducer и произойдет обычная логика.
            Если на входе придет функция thunk, она зайдет в thunk MW который определит что это функция thunk - он ее
        запустит, закинет туда dispatch функцию, а в thunk прописанны диспатчи обычных action, и эти обычные action
        по кругу придут в store.dispatch -> thunk MW -> reducer.
            Если внутри thunk задиспатчим другую thunk, то в store.dispatch задиспатчится thunk которая попадет
        в thunk MW которую он снова запустит, и в нутри той санки будут диспатчи обычных action, когда цикл закончится, в
        конечном итоге reducer получит обычные action кторые преобразуют state и будет результат.
            Нужно redux для всего этого настроить и вклинить в него midleware