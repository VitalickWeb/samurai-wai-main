60 - withRouter, props.match.params

withRouter - это компонента высшего порядка.

    Рассмотрим такой момент, у нас есть презентационная компонента Users - изолированная оторванная от store,
но получать данные ей нужно и нужно диспатчить в store что-то, а засорять ее мы не хотим данными
поэтому используем функцию connect, которая на выходе создает контейнерную компоненту и эта контейнерная
компонента берет на себя всю работу, коннектится к store через mstp и mdtp, прокидывая данные из state и
колбэки, которые вызовутся и произведут изменения в store. И в функцию коннект мы можем просунуть
любую презентационную компоненту и она во круг презентационной компоненты создаст какую то контейнерную
компоненту. И та контейнерная компонента какие-то данные прокинет в презентационную.

    У нас пока есть два уровня - UI и BLL где ui это библиотека которая эффективно умеет отрисовывать
HTML - реагировать на действие пользователя. И механизм управления стэйтом, классовые компоненты setState
метод и хуки useState.
    Нам не нужно стэйтом засорять реакт так как это уровень бизнес логики - какие то данные. И так как
приложение большое мы не хотим засорять наши компоненты.
    Redux это название библиотеки, у которой есть store который является хранителем state. Именно в стор мы
диспатчим что либо из  стора получаем стэйт говорим getState дай мне стэйт и mstp прокидывает это в наши UI
components.
    Когда мы что то нажимаем мы что то диспатчим через store.dispatch, когда мы что то диспатчим стор
по итогу берет action и прокидывает по всем редьюсерам и стэйт преобразовывается. И так по кругу. Flux
круговорот один источник истины.
 Но появляется второй источник истины URL адрес, адрес в адресной строке браузера.
 Мы хотм отобразить в profile например 10 номер пользователя, а отображается все время захардкоженный 2
получается что мы не реагируем на эту истину, а URL адрес по сути является источником истины,
который можно скопировать и вставить в новую вкладку. Это истина с котрой рождается движение являющейся
подсказкой для бизнес логики - какой там профиль будет сидеть и в нашей системе появляется новый источник
истины схожий с нашим redux state, текущий URL. По сути мы должны этот URL в компоненте прочитать или
в BLL - это философский вопрос - когда в системе 2 источника истины, то добавляет путаницы кто
курица, а кто яйцо. Откуда должна быть по итогу конечная синхронизация, как BLL привести в синхрон с
этим URL, вроде как URL первичен, но BLL является ядром системы, а ui позволяет благодаря withRout
взаимодействовать с этим URL и мы из ui можем изменять этот URL. Поэтому на практике рассмотрим базовый
стандартный подход, который является применимым на практике.

    В итоге выбираем такой подход: У нас ui может прочитать из источника URL что либо. И из BLL
может прочитать. Если UI прочтет что либо из URL то может задиспатчить в BLL что либо BLL обновится
и будет flux круговорот работать. Нужно прочитать Id пользователя и загрузить его профиль.
1)В Profile Id 10 этот id приходит в ui компоненту
2)компонента делает Ajax запрос на сервер в методе componentDidMount
3)берет id 10
4)10 user возвращается обратно в response объект profile
5)И мы этот профиль диспатчим в BLL.

    Все что компоненте нужно, нельзя импортировать и брать из глобальных файлов, только прокидывать через пропсы!
Только в этом случае компоненту можно нормально контролировать и тестировать. Если нужны данные не из стора а из
URL то есть специальная функция для этого которая будет брать данные из url - называется такая функция withRouter
буквально (с маршрутом) - в эту компоненту через пропсы придут данные рассказывающие о том где мы сейчас находимся
какой у нас маршрут.

Загружается компонента Profile, находим то место где делаем запрос на сервер. Куда приходит загруженный профиль
контейнерной компонентой.
    Для Profile создается контейнерная компонента, 1) создается единожды как классовая компонента, именно в ней
происходит запрос на сервер, 2)Потом контейнерную компоненту еще раз оборачиваем connect - который делает другую
работу, получает данные от store и callback, 3)Создаем третью контейнерную контейнерную компоненту
withRouter(обернутая компонента) над этими всеми компонентами, для того что бы прокинуть в нашу конечную
компоненту данные из URL

    В методе componentDidMount ставим дебагер как раз там где нужны данные из урла, в место фиксированного значения
взять данные из адресной строки браузера. И смотрим что приходит в пропсах, в консоли пишем this.props нажимаем
Enter, на данном этапе profile: null так как еще не отправили запрос на сервер, и null пришел из state reducer.
И есть так же функция callback setUserProfile которая может задиспатчить что то в store, чтобы установить профиль.

    WithRouter работает так же как и connect возвращает новую компоненту, которая по факту отрисует презентационную,
но закинет в нее данные из store. А в случае WithRouter данные закинет из url.

##################################################################################################################
    И получается, что у нас есть контейнерная компонента созданная в ручную,которая рисует Profile - который находится
в самом ядре которую оборачивают КонтКомонентой для того что бы сделать запрос на сервер, но что бы сделать запрос
на сервер, она должна получить данные из URL, поэтому нашу контейнерную компоненту оборачиваем в вызов функции
WithRouter(container component)
    WithRouter возвращает другую компоненту которая займется тем что в profile компоненту контейнерную закинет
данные из Url -> потом эту же компоненту закидываем в connect чтобы connect тоже закинул данные в profile.
##################################################################################################################

##################################################################################################################
<BrowserRouter> мы оборачиваем наше все содержимое для того чтобы дочерние компоненты могли достучатся через
context к данным которые поставляются router provider
##################################################################################################################

    Ставим дебаггер и смотрим что пришло нам в this.props в console.log и видим что там появились объекты match,
location, history и в объекте появился staticContext.
Смотрим содержимое объектов: location путь в котором мы находимся hash: "", pathName: "/profile/10" - адресная строка
нам пока не нужны, а вот match(совпадение) - совпадение нашего url с какими то роутами, совпадение было найдено
с путем profile - url: "/profile" и path: "/profile" дальше идут параметры params: {} - которым является id 10
но в маршруте match не сказано что это параметр, поэтому параметр пустой, параметра нет. Поэтому нам нужно сделать так
чтобы в match: { params: {} } было значение.
    isExact: false означает что rout совпал с этим путем "/profile" но не точ в точ. Потому что в path: "/profile" а
    в URL у нас "/profile/10"
    И поэтому мы сделаем так, чтобы система реакта сама распознавала параметр и происходило совпадение.
Если параметра нет то показываем наш профиль, а если есть то показываем профиль того параметра с которым произошло
совпадение. Обозначается параметр с помощью двоеточия и имени параметра path="/profile/:userId" параметры можно
добавлять path="/profile/:userId/:second/" и все доставать с помощью этого синтаксиса.
    И теперь записав в переменную путь эту переменную можем прикрепить к основному пути через конкатенацию.

    axios.get(`https://social-network.samuraijs.com/api/1.0/profile/` + userId).then(response => {
        this.props.setDataUser(response.data)
    })
 что бы в последствии наша страница с профилем не была пустая, то нужно добавить ? вопросительный знак, как
 не обязательный параметр и сделать условие перед гет запросом на сервер если нет юзера то присваиваем то что мы
 хотим видеть.

 <Route path="/profile/:userId?" render={() =><ProfileContainer/>}/>
