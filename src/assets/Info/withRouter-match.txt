60 - withRouter, props.match.params

withRouter - это компонента высшего порядка.

    Рассмотрим такой момент, у нас есть презентационная компонента Users - изолированная оторванная от store,
но получать данные ей нужно и нужно диспатчить в store что-то, а засорять ее мы не хотим данными
поэтому используем функцию connect, которая на выходе создает контейнерную компоненту и эта контейнерная
компонента берет на себя всю работу, коннектится к store через mstp и mdtp, прокидывая данные из state и
колбэки, которые вызовутся и произведут изменения в store. И в функцию коннект мы можем просунуть
любую презентационную компоненту и она во круг презентационной компоненты создаст какую то контейнерную
компоненту. И та контейнерная компонента какие-то данные прокинет в презентационную.

    У нас пока есть два уровня - UI и BLL где ui это библиотека которая эффективно умеет отрисовывать
HTML - реагировать на действие пользователя. И механизм управления стэйтом, классовые компоненты setState
метод и хуки useState.
    Нам не нужно стэйтом засорять реакт так как это уровень бизнес логики - какие то данные. И так как
приложение большое мы не хотим засорять наши компоненты.
    Redux это название библиотеки, у которой есть store который является хранителем state. Именно в стор мы
диспатчим что либо из  стора получаем стэйт говорим getState дай мне стэйт и mstp прокидывает это в наши UI
components.
    Когда мы что то нажимаем мы что то диспатчим через store.dispatch, когда мы что то диспатчим стор
по итогу берет action и прокидывает по всем редьюсерам и стэйт преобразовывается. И так по кругу. Flux
круговорот один источник истины.
 Но появляется второй источник истины URL адрес, адрес в адресной строке браузера.
 Мы хотм отобразить в profile например 10 номер пользователя, а отображается все время захардкоженный 2
получается что мы не реагируем на эту истину, а URL адрес по сути является источником истины,
который можно скопировать и вставить в новую вкладку. Это истина с котрой рождается движение являющейся
подсказкой для бизнес логики - какой там профиль будет сидеть и в нашей системе появляется новый источник
истины схожий с нашим redux state, текущий URL. По сути мы должны этот URL в компоненте прочитать или
в BLL - это философский вопрос - когда в системе 2 источника истины, то добавляет путаницы кто
курица, а кто яйцо. Откуда должна быть по итогу конечная синхронизация, как BLL привести в синхрон с
этим URL, вроде как URL первичен, но BLL является ядром системы, а ui позволяет благодаря withRout
взаимодействовать с этим URL и мы из ui можем изменять этот URL. Поэтому на практике рассмотрим базовый
стандартный подход, который является применимым на практике.

    В итоге выбираем такой подход: У нас ui может прочитать из источника URL что либо. И из BLL
может прочитать. Если UI прочтет что либо из URL то может задиспатчить в BLL что либо BLL обновится
и будет flux круговорот работать. Нужно прочитать Id пользователя и загрузить его профиль.
1)В Profile Id 10 этот id приходит в ui компоненту
2)компонента делает Ajax запрос на сервер в методе componentDidMount
3)берет id 10
4)10 user возвращается обратно в response объект profile
5)И мы этот профиль диспатчим в BLL.

Загружается компонента Profile, находим то место где делаем запрос на сервер.