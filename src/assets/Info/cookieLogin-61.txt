            Что такое логинизация и как она устроена.

    Мы есть в браузере, и вот мы отправляем на страницу логина свой пароль и логин, сервер ананлизирует
и возвращает ответ в зависимости от того что мы отправляем.
    Мы залогинены и делаем запрос за сообщениями, и говорим в запросе дать нам сообщения не говоря
при этом кто мы и сервак почему то возвращает нам наше сообщения. Айдишку мы тоже не можем переслать
так как это нельзя делать. Или делаем запрос на друзей говорим дай мне моих друзей и сервер определяет
что это именно мы. То есть что-то произошло в момент логинизации, даже после перезагрузки страницы
у нас есть состояние залогиненности, что мы сразу отправляем запросы именно за нашими сообщениями и они нам
приходят.
    Как это происходит?
    В браузере хранятся cookie для каждого сайта. Условно говоря эта кука пустая. Кука это текстовый файлик,
который хранится для каждого сайта.
    Кука это файл который цепляется ко всем запросам на сервер, это происходит автоматически, за сообщениями
или за друзьями и тд. И сервер например говорит ошибка и возвращает куку обратно пустую условно говоря.
Кука говорит дай мне сообщение, а сервер спрашивает кто ты. И это связанно именно с нашей индетификацией.

    Если мы отправляем пустую куку на сервер она автоматически цепляется, отправляем логин и пароль на
сервер и сервер подтверждает что да это мы, то сервер записывает в куку наш идентификатор, и отправляет
его в закодированном виде. Она возвращается назад и записывается браузером автоматически до тех пор пока
 кука не умрет (в ней установлен момент когда она должна умереть). Когда на форме логина мы ставим
галочку запомнить меня - это и есть про время жизни куки. Если ставим галочку то куки будет жить месяц
например или продлевать жизнь при каждом запросе.
    Если галочку не ставим, то кука будет жить условно пол часа пока сессия не завершится. Вывод:
галочка означает время жизни куки.
    Соответственно теперь с каждым запросом на сервер будет отправляться кука с идентфикационным
номером, и сервер будет знать кому отправлять на запрос ответ.

    Что у нас происходит. У нас два сервера. 1)социальная сеть апишка куда мы делаем запросы, 2)
    второй наш локалхост на коотром мы разворачиваем наше приложение SPA index.html кука для нашего
    домена одна, для другого домена другая. И когда в браузер загрузился наш html в браузере живет
    наше приложение, которое загрузилось с localeHost, а когда мы будем делать запросы с нашего
    локалхоста на api - это называется кросдоменные запросы - 'корсс'. Запрещено с одного домена
    делать запросы на другой домен, только если этот домен не разрешил этих запросов. То есть
    сервер должен разрешить эти запросы обратно нам в браузер, если он разрешает,
    то тогда браузер пропустит этот запрос и все будет хорошо. Корс политика безопастности - политика
    браузера.

    Если вдруг мы api на сервере залогинимся не с нашей index.html а просто залогинимся, то потом когда
кука создастся именно для домена в браузере уже будет сидеть кука для домена. Мы потом загружаем индекс
штмл, делаем запрос на api social Network и у нас кука уже сидит - мы в системе залогинены.
Это значит что если перейти на social Network и мы увидим что мы залогины, наша api у нас
https://social-network.samuraijs.com/ тот же самый домен, значит кука та же самая. То есть если
я залогинился здесь, значит сейчас я могу делать запросы к этой api и эти запросы будут авторизованными.
Кука автоматически будет цеплятся и сервер будет понимать что я залогинен.

    Откроем документацию auth/me и скажем user authorized, мы делаем запрос на auth/me и нам сервак отвечает
что отвечает смотрим в response. Request нет, запрос ни какой не делается, просто get запрос на /auth/me эту
строку, а в ответе нам придет объект данных. resultCode: 0 - означает все хорошо, ошибки ни какой не
произошло мы залогинены. И в объекте свойстве data находятся userId, login, email. Как назовет серверный
разработчик. А если мы не авторизованы то ответ будет иным.
{
"data": {}, данных нет
"messages": [
"You are not authorized" в сообщении приходит о том что вы не авторизованны
],
"fieldsErrors": [],
"resultCode": 1   ошибка авторирзации
}
    Где мы это можем применить. Со старта нашего приложения мы можем отправить запрос в строку браузера
и нам придет ответ залогинены мы или нет. И на основании этих данных мы можем нашу соц сеть проецировать
и строить, дальше ее развивая. Прятать в хэдере или показывать сссылку на логин или фото пользователя.

    Начнем с того что назовем наш редьюсер auth-reducer - так как у нас бизнес логика живет отдельно от UI
хоть и будем использовать этот редьюсер на данном этапе для компоненты Header. Это часть нашего state
и логики который будет отвечать за то что кто мы сейчас залогинены или нет, пользователь текущий котрый
пользуется нашим приложением.
    В initialState мы сделаем что бы было меньше расхождения BLL с API так как мы получаем от сервера какие
то данные и как правило мы потом их проецируем к себе в свои объекты и ими пользуемся.

    Свойства которые придут к нам с сервера userId, login, email - мы создадим в своем редьюсере для
аутенцификации. isFetching: false со старта загрузки нет, потом по запросу загрузка происходит.
userId, login, email - со старта все null. С сервера может прийти ответ нам что - ты не залогинин
или придут выше перечисленные данные. SET-USER-DATE к нам приходят с сервера эти данные и мы их
устанавливаем перезатирая все что было в старом state. Эти данные всегда приходят к нам в action
потому что все данные в редьюссере которые нужны для преобразования state всегда лежат в action!
В action мы создадим один объект котрый будет называтся например data и мы его деструктуризируем.
В этот объект положим наши данные которые нам пришли с сервера userId, login, email и у нас они в action
они будут лежать не отдельно а в объекте данных. Тоесть делаем двойную диструктуризацию из объектов
тем самым склеивая их. те данные action которые сидят ниже перезатрут данные которые сидят в state.

action creator задача этой функции вернуть объект action который задиспатчим в редьюсер.
и в свойство ...action.data нужно упаковать все эти свойства. И добавить редьюсер в redux.

Теперь в Header добавлям login добавляем его в navlink to='/login' переходим на страницу логина.
На этой странице у нас должна быть форма для логинизации, но мы уже до этого залогинились. Если
перейдем на соц сеть, на API мы видим что мы залогинены там. Поэтому информация на логине не правильная
потому что все запросы которые будут идти с нашего локалхоста на social nertwork API они будут
авторизованными, потому что мы залогинены на сайте на том же самом домене на котором и api сидит,
и кука сидит в нашем браузере. Поэтому ко всем запросам которые будут идти на сервер будет добавлятся
наш cookie.
    Делаем запрос в контейнерной компоненте Header и получим данные о нас, кто мы такие. /auth/me
    Создаем классовую компоненту которая экстендит реакт компонент - расширяет базовый класс компоненты.
и возвращает в методе render() jsx.

    Смотрим в дебагере что нам пришло в запросе с сервера. Сервак говорит что мы не авторизованы
почему так происходит, если мы авторизованны? Потому что кроссдоменные запросы и браузер не  отправляет
куку автоматически. Как бы хочет удостоверится точно хочешь сделать кросдоменный запрос, точно хочешь цеплять
cookie.
    Поэтому вторым параметром в запросе мы передаем специальный объект в котром сидят настройки запроса.
И мы говорим withCredentials: true и тогда нам придет что мы авторизованны. Наш Header узнал об этом и
он может теперь взять и задиспаьчить эту информацию в редьюсеры.
    В респонсе мы должны сделать проверку if (responce.data.resultCode === 0) в этом случае мы только
должны задиспатчить авторизацию. this.props.setUserDate(берем их из responce.data.data.login)
Axios упаковывает структуру в data. если не знаем какая структура должна быть ставим дебаггер и
изучаем. Деструктуризируем передачу данных, обязательно в правильном порядке.
    Когда мы залогинены в метсо кнопки login нужно показывать имя пользователя. Использем для этого
булево значение которое будет четко говорить true или false и если пришли пользовательские данные,
мы одновременно isAuth делаем true. Поэтому в mapStateToProps, берем из state что нам надо. isAuth и login.
Эти данные придут в HeaderContainer компоненту которая прокинет их через диструктуризацию пропсов
{...this.props} дальше в header и наш хедер может реагировать достав эти значения из пропсов и показать
login или name.
